Convert search trees to use templates.

Make documentation more consistent and complete.

Define canonical form of bipartite graphs as having consistent
left and right edges. Add methods to test if a vertex is left
or right. Those with no edges are treated as right.
Should we have iteration methods?

Add iteration methods to ClistSet. Requires marking one vertex
in each list as the first and returning it on a join or remove.
Each list in set has a "label" in 1..n, which may change when
set changes.

Consider general re-naming. Many data structures are essentially
partition maintenance where partitions have different properties.
- partition sets may be labeled or not (or maybe always labeled?)
- elements may be ordered or not
- elements may be sorted by keys or not
So, current partition might be Lpartition (for labeled),
ClistSet might be Opartition (for ordered)
Search trees might be Spartition (for sorted)
- with virtual base class for common stuff and subclasses for specific cases
What about Fheaps and leftist heaps?
Continuing tension between names that describe abstract properties
and those that describe specific implementations. Not clear how
best to resolve. Maybe answer is to combine both.
For partition maintenance, revert to disjoint sets.
So basic merge partition becomes djsets-fl (for find-link),
clistset becomes djsets_cl (for circular list).
Binary search trees become ssets, ssets_sa (self-adjusting),
Ssets_rb (red-black)
Heaps become heap_r (r for regular, since almost all nodes have d children),
Djheaps_f (fib), Djheaps_l (leftist), Djheaps_ll (lazy leftist).
Graph, Graph_d (directed), Graph_w (weighted), _wd, _f (flow), _ff (flows with floors), _wf (weight)

Similar thoughts for algorithms.
Mst algorithms become mst_p, mst_k, mst_ct (cheriton-tarjan).
Spt become spt_d (dijkstra), spt_bfs.
All pairs becomes apsp-f (floyd), apsp-ek (edmonds-karp)
Max flow becomes maxf_ff, maxf_d, maxf_dst etc.
Min-cost flow becomes mcf_sp (shortest augmenting path),
mcf_cr (cycle reduction) 
Matching: match_eg (edmonds-gabow), matchb_hk (hopcroft-karp),
matchwb_h (hungarian), matchw-egmg (edmonds/galil...)






Add memSpace methods to data structures to facilitate
space calculations. Not sure can do this for templates.
Maybe can. Would require objects used in templates to
support this, but we already requre toString, so maybe
it's ok.

Might want to auto-adjust space in HashSet if both
buckets are full on an insert. Note that this could
make hash table pretty sparse. Not likely to happen,
but possible.

Rework matching stuff
- integrate fast initialization, drop separate "fast" versions
  maybe not; re-evaluate fast versions; may be that only the
  initial maximal matching is really worth the trouble
- make class hierarchy for edmonds variants
- add private visited(x) method that compares phase to lastVisit(x)
  to make efficient versions more transparent

Use templates for keys in heaps and search trees.
Started on this, including HashSet and HashMap.

Add unit tests for all data structures.
- consider alternate designs for this
- fully scripted version is nice, but more automated version
  might be better, rather than always comparing to strings;
  also requires lots of test methods, making it cumbersome

Augment the Java stuff. Maybe do some animations?
Revisit the efficiency comparison using inline Java methods.
Ron Cytron says that if a method is private or final, it
can be inlined. I guess final is the only useful one here.
